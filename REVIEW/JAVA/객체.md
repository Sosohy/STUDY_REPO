### 객체
- 클래스의 인스턴스로, 클래스에서 정의된 필드와 메소드를 실제로 사용하는 실체
  - 독립적이면서 하나로 취급되는 사물이나 개념
- new 연산자를 사용하여 클래스의 인스턴스를 생성
  - heap에 할당된 공간(== 인스턴스)
  - heap 메모리 공간에 서로 다른 자료형의 데이터가 연속으로 나열/할당된 인스턴스 공간
![](https://velog.velcdn.com/images/hso07202/post/5d72c3b1-1bde-49b9-885c-4782dd4fc016/image.png)

---

### 객체지향 프로그래밍(OPP)
- Object Oriented Programming language
- 현실 세계의 모든 사건(event)는 객체와 객체의 상호작용에 의해 일어난다는 세계관을 프로그램을 만들 때 이용하여 새로운 세계를 창조하는 방법론
- 추상화, 캡슐화, 상속, 다형성을 적용하여 유지보수성을 고려한 응집력 높고 결합도 낮은 **객체 위주의 개발 방식을 적용한 프로그래밍**
- 모든 객체는 적절한 책임을 가지고 있어야 한다. → 단일 책임의 원칙 
- 코드 재사용성, 유지보수성, 확장성, 모듈화

#### 객체지향의 4대 특징
- 추상화(Abstraction), 캡슐화(Encapsulation), 상속(Inheritance), 다형성(Polymorphism)

---

### 추상화(Abstraction)
- 유연성 확보를 위해 공통 부분을 추출하고 공통적이지 않고 불필요한 부분을 제거하는 것
- 현실세계의 복잡한 사건을 **단순화**하여 새로운 객체 지향 세계를 창조해 나가는 과정
- 추상화 과정을 통해 객체(Object)가 도출
- 목적
  - 재사용성 증가
  - 유지보수성
  
![](https://velog.velcdn.com/images/hso07202/post/6bed7000-8402-44b8-8608-9999a9bec1ba/image.png)

### 캡슐화(Encapsulation)
- 객체의 속성과 행위를 하나로 묶고 필드에 간접적으로 접근하여 사용할 수 있도록 클래스를 작성하는 기법
- 낮은 결합도를 위해 필드의 직접 접근을 제한하고, public 메소드를 이용
- 목적
  - 유지보수성 증가
  
| 구분 | 같은 클래스 | 같은 패키지  | 자식 클래스 | 전체 |
| --- | --- | --- | --- | --- |
| public | O | O | O | O |
| protected | O | O | O |  |
| (default) | O | O |  |  |
| private | O |  |  |  |  

- 필드에 직접 접근 시 발생할 수 있는 문제점
  - 필드에 올바르지 않은 값이 들어가도 통제가 불가능.
  - 필드의 이름이나 자료형을 변경할 때 사용하는 쪽에도 수정 영향을 미침.

### 상속(Inheritance)
- 부모 클래스가 가지는 멤버(필드, 메소드)를 자식 클래스가 물려 받아 자신의 것처럼 사용할 수 있도록 만든 기술
  - 생성자는 물려 받지 않음
- 멤버 외에도 부모 클래스의 타입 또한 상속 가능(다형성의 토대)
- 자바는 단일 상속만 지원
- extends 키워드 사용
```java
public class Academy extends Company {

}
```
- 사용 이유
  - 기존에 작성 된 클래스의 멤버를 **재사용**
    - 생산성, 유지보수성 ↑
  - 클래스 간 계층 관계를 형성하여 다형성 문법의 토대가 됨

#### IS-A
- “자식 클래스는 (하나의)부모 클래스이다.”라는 말을 만족(성립)하는 관계를 뜻하며 클래스 간 상속 관계를 파악하기 위한 키워드
- Circle is a Shape 원은 하나의 모양이다.
  
#### super와 super()
- super
  - 자식 클래스 타입의 객체가 생성될 때, 먼저 생성된 부모 클래스 타입의 객체의 주소값(참조값)을 통해 접근
- super()
  - 부모 생성자를 호출하는 구문으로 인자와 매개변수의 타입, 갯수, 순서가 일치하는 부모의 생성자를 호출
  - private 생성자를 제외한 나머지 생성자 호출 가능
  
### 다형성(Polymorphism)
- 하나의 인스턴스가 여러 가지 타입을 가질 수 있는 것
- 하위 타입을 상위 타입 하나로 관리 가능
- 장점
    - 여러 타입의 객체를 하나의 타입으로 관리할 수 있기 때문에 유지보수성과 생산성이 증가된다.
    - 상속을 기반으로 한 기술이기 때문에 상속관계에 있는 모든 객체는 동일한 메세지를 수신할 수 있다. 이런 동일한 메세지를 수신받아 처리하는 내용을 객체별로 다르게 할 수 있다는 장점을 가지고 있다. (다양한 기능을 사용하는데 있어서 관리해야 하는 메세지 종류가 줄어들게 된다.)
    - 확장성이 좋은 코드를 작성할 수 있다.
    - 결합도를 낮춰서 유지보수성을 증가시킬 수 있다.
```java
/* 설명. 다형성 적용(부모 타입으로 자식 인스턴스의 주소값 저장) */
 Animal an1 = new Tiger();     // 다형성 적용 
 Animal an2 = new Rabbit();    // 다형성 적용
 Animal an3 = new Animal();    // 부모 자신의 타입은 다형성이 아님
```

#### 동적바인딩
- 컴파일 당시에는 해당 타입의 메소드와 연결되어 있다가 런타임 시 실제 해당 인스턴스가 메소드(오버라이딩 한 메소드)로 바인딩이 바뀌어 동작하는 것을 의미
- 성립조건 : 상속 관계를 가지는 부모 자식 클래스에 오버라이딩 된 메소드를 호출해야 한다.
  - 상속, 오버라이딩

#### 업캐스팅, 다운캐스팅
- 상속관계에 있지만, 후손 객체가 고유하게 가지는 확장된 기능을 사용하기 위해서는 실제 인스턴스의 타입으로 다운캐스팅(클래스 형변환) 필요
- 상위 타입 형변환의 경우 묵시적으로 일어나며, 하위 타입 형변환은 명시적으로 작성해야 함

#### instance of
- 레퍼런스 변수가 실제로 어떤 클래스 타입의 인스턴스인지 확인하여 true or false를 반환

```java
Car car = new Sonata();
if(car instanceof Sonata) {  // 실제 타입 확인하여 다운캐스팅
		((Sonata) car).moveSonata(); 
} else if(car instanceof Avante) {
		((Avante) car).moveAvante();
} else if(car instanceof Grandure) {
		((Grandure) car).moveGrandure();
}
```

#### 💡 오버로딩/오버라이딩

#### 오버로딩
- **동일한 메소드명**으로 **다양한 종류의 매개변수에 따라 다르게 처리**하기 위해 사용
- 동일한 메소드명의 매개변수의 타입, 개수, 순서를 다르게 작성
  - 메소드의 시그니처가 다르지만 메소드명은 동일하게
  - 매개변수로 사용 가능한 자료형
    - 기본자료형, 기본자료형 배열, 클래스 자료형, 클래스 자료형 배열, 가변인자

#### 오버라이딩
- 부모클래스에서 **상속받은 메소드를 자식 클래스가 재정의**
- 오버라이딩 성립 조건
  1. 메소드명 동일
  2. 메소드 리턴타입 동일
  3. 매개변수의 타입, 개수, 순서가 동일
  4. 부모 클래스의 private 메소드는 오버라이딩 불가능
  5. 부모 클래스의 final 키워드가 사용된 메소드는 오버라이딩 불가능
  6. 접근제어자는 부모 메소드와 같거나 더 넓은 범위여야 함
  7. 예외처리는 같은 예외이거나 더 구체적(하위)인 예외를 처리해야 함
 
#### 오버라이딩과 오버로딩 비교
- ![](https://velog.velcdn.com/images/hso07202/post/4bad5321-d8d3-4fe4-8139-d127b7fd1017/image.png)
